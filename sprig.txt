/*
First time? Check out the tutorial game:
https://sprig.hackclub.com/gallery/getting_started

@title: Tetris?
@author: Gautham Nair
@tags: []
@addedOn: 2024-00-00
*/
const White = "W";
const Black = "B"
const Grey = "G"
const Blue = "b"
const DBlue = "D"
const Orange = "O"
const Yellow = "Y"
const Green = "g"
const Purple = "P"
const Red = "R"

// Stick, L, L2, S, S2, Square, and Pyramid (order) 
var pieces = [
  [map`
..b.
..b.
..b.
..b.`, map`
....
....
bbbb
....`, map`
.b..
.b..
.b..
.b..`, map`
....
bbbb
....
....`],
  [map`
.O.
.O.
.OO`, map`
...
OOO
O..`, map`
OO.
.O.
.O.`, map`
..O
OOO
...`],
  [map`
.DD
.D.
.D.`, map`
...
DDD
..D`, map`
.D.
.D.
DD.`, map`
D..
DDD
...`],
  [map`
.g.
.gg
..g`, map`
...
.gg
gg.`, map`
g..
gg.
.g.`, map`
.gg
gg.
...`],
  [map`
..R
.RR
.R.`, map`
...
RR.
.RR`, map`
.R.
RR.
R..`, map`
RR.
.RR
...`],
  [map`
.YY
.YY
...`, map`
.YY
.YY
...`, map`
.YY
.YY
...`, map`
.YY
.YY
...`],
  [map`
.P.
.PP
.P.`, map`
...
PPP
.P.`, map`
.P.
PP.
.P.`, map`
.P.
PPP
...`],
]

// var skirts = [
//   [map`
// ..
// ..
// ..
// .b`, map`
// ....
// bbbb`, map`
// ..
// ..
// ..
// b.`, map`
// bbbb
// ....`],
//   [map`
// ...
// ...
// .OO`, map`
// ...
// .OO
// O..`, map`
// O..
// ...
// .O.`, map`
// ...
// OOO
// ...`],
//   [map`
// ..D
// ...
// .D.`, map`
// ...
// DD.
// ..D`, map`
// ...
// ...
// DD.`, map`
// ...
// DDD
// ...`],
//   [map`
// ...
// .g.
// ..g`, map`
// ...
// ..g
// gg.`, map`
// ...
// g..
// .g.`, map`
// ..g
// gg.
// ...`],
//   [map`
// ...
// ..R
// .R.`, map`
// ...
// R..
// .RR`, map`
// ...
// .R.
// R..`, map`
// R..
// .RR
// ...`],
//   [map`
// ...
// .YY
// ...`, map`...
// .YY
// ...`, map`
// ...
// .YY
// ...`, map`
// ...
// .YY
// ...`],
//   [map`
// ...
// ..P
// .P.`, map`
// ...
// P.P
// .P.`, map`
// ...
// P..
// .P.`, map`
// ...
// PPP
// ...`],
// ]

setLegend(
  [White, bitmap`
2222222222222222
2222222222222222
2222222222222222
2222222222222222
2222222222222222
2222222222222222
2222222222222222
2222222222222222
2222222222222222
2222222222222222
2222222222222222
2222222222222222
2222222222222222
2222222222222222
2222222222222222
2222222222222222`],
  [Black, bitmap`
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000`],
  [Grey, bitmap`
LLLLLLLLLLLLLLLL
LLLLLLLLLLLLLLLL
LLLLLLLLLLLLLLLL
LLLLLLLLLLLLLLLL
LLLLLLLLLLLLLLLL
LLLLLLLLLLLLLLLL
LLLLLLLLLLLLLLLL
LLLLLLLLLLLLLLLL
LLLLLLLLLLLLLLLL
LLLLLLLLLLLLLLLL
LLLLLLLLLLLLLLLL
LLLLLLLLLLLLLLLL
LLLLLLLLLLLLLLLL
LLLLLLLLLLLLLLLL
LLLLLLLLLLLLLLLL
LLLLLLLLLLLLLLLL`],
  [Blue, bitmap`
7777777777777777
7777777777777777
7777777777777777
7777777777777777
7777777777777777
7777777777777777
7777777777777777
7777777777777777
7777777777777777
7777777777777777
7777777777777777
7777777777777777
7777777777777777
7777777777777777
7777777777777777
7777777777777777`],
  [DBlue, bitmap`
5555555555555555
5555555555555555
5555555555555555
5555555555555555
5555555555555555
5555555555555555
5555555555555555
5555555555555555
5555555555555555
5555555555555555
5555555555555555
5555555555555555
5555555555555555
5555555555555555
5555555555555555
5555555555555555`],
  [Orange, bitmap`
9999999999999999
9999999999999999
9999999999999999
9999999999999999
9999999999999999
9999999999999999
9999999999999999
9999999999999999
9999999999999999
9999999999999999
9999999999999999
9999999999999999
9999999999999999
9999999999999999
9999999999999999
9999999999999999`],
  [Yellow, bitmap`
6666666666666666
6666666666666666
6666666666666666
6666666666666666
6666666666666666
6666666666666666
6666666666666666
6666666666666666
6666666666666666
6666666666666666
6666666666666666
6666666666666666
6666666666666666
6666666666666666
6666666666666666
6666666666666666`],
  [Green, bitmap`
4444444444444444
4444444444444444
4444444444444444
4444444444444444
4444444444444444
4444444444444444
4444444444444444
4444444444444444
4444444444444444
4444444444444444
4444444444444444
4444444444444444
4444444444444444
4444444444444444
4444444444444444
4444444444444444`],
  [Purple, bitmap`
HHHHHHHHHHHHHHHH
HHHHHHHHHHHHHHHH
HHHHHHHHHHHHHHHH
HHHHHHHHHHHHHHHH
HHHHHHHHHHHHHHHH
HHHHHHHHHHHHHHHH
HHHHHHHHHHHHHHHH
HHHHHHHHHHHHHHHH
HHHHHHHHHHHHHHHH
HHHHHHHHHHHHHHHH
HHHHHHHHHHHHHHHH
HHHHHHHHHHHHHHHH
HHHHHHHHHHHHHHHH
HHHHHHHHHHHHHHHH
HHHHHHHHHHHHHHHH
HHHHHHHHHHHHHHHH`],
  [Red, bitmap`
3333333333333333
3333333333333333
3333333333333333
3333333333333333
3333333333333333
3333333333333333
3333333333333333
3333333333333333
3333333333333333
3333333333333333
3333333333333333
3333333333333333
3333333333333333
3333333333333333
3333333333333333
3333333333333333`],
)

var gameOver = false;
var game = map`
GGGGGGGGGG
GGGGGGGGGG
GGGGGGGGGG
GGGGGGGGGG
GGGGGGGGGG
GGGGGGGGGG
GGGGGGGGGG
GGGGGGGGGG
GGGGGGGGGG
GGGGGGGGGG
GGGGGGGGGG
GGGGGGGGGG
GGGGGGGGGG
GGGGGGGGGG
GGGGGGGGGG
GGGGGGGGGG
GGGGGGGGGG
GGGGGGGGGG
GGGGGGGGGG
GGGGGGGGGG`
var gameState = map`
..........
..........
..........
..........
..........
..........
..........
..........
..........
..........
..........
..........
..........
..........
..........
..........
..........
..........
..........
..........`

var pieceType = -1;
var pieceRot = 3;
var pieceLoc = [-1, -1];

function updateTile(x, y, newTile) {
  const rows = game.trim().split("\n"); // Trim excess spaces and split into rows
  const maxWidth = Math.max(...rows.map(row => row.length)); // Find the maximum row width

  // Update the specific tile at (x, y) with newTile
  let updatedRow = rows[y];
  // updatedRow = updatedRow.padEnd(maxWidth, ' '); // Pad the row to match maxWidth
  updatedRow = updatedRow.substring(0, x) + newTile + updatedRow.substring(x + 1);

  rows[y] = updatedRow;
  game = rows.join("\n");


}

function updateTileState(x, y, newTile) {
  const rows = gameState.trim().split("\n"); // Trim excess spaces and split into rows
  const maxWidth = Math.max(...rows.map(row => row.length)); // Find the maximum row width

  // Update the specific tile at (x, y) with newTile
  let updatedRow = rows[y];
  updatedRow = updatedRow.padEnd(maxWidth, ' '); // Pad the row to match maxWidth
  updatedRow = updatedRow.substring(0, x) + newTile + updatedRow.substring(x + 1);

  rows[y] = updatedRow;
  gameState = rows.join("\n");

}

function getGameTile(x, y) {
  return game[(11 * y) + x];
}

function getStateTile(x, y) {
  return gameState[(11 * y) + x];
}

function addPiece(pieceNum) {
  var piece = pieces[pieceNum][3];
  var pieceRows = piece.trim().split("\n");
  pieceType = pieceNum;
  pieceLoc = [5, 1];
  pieceRot = 3;
  var y = 0;
  for (row of pieceRows) {
    var x = 4;
    for (cell of row) {
      if (cell === ".") { cell = "G" } else {
        updateTileState(x, y, "p")
        if (getGameTile(x, y) != "G") {
          gameOver = true;
        }
      };
      updateTile(x, y, cell);
      x++;
    }
    y++;
  }
}

function pieceUpdate() {
  let rowsRev = gameState.trim().split("\n").reverse();
  let anyFall = false;
  const gameCopy = game;
  const gameStateCopy = gameState;
  for (var y = 19; y > 0; y--) {
    for (var x = 0; x < 10; x++) {
      cell = getStateTile(x, y);
      cellAbove = getStateTile(x, y - 1);
      if (cell === "." && cellAbove === "p") {
        updateTileState(x, y, cellAbove);
        updateTileState(x, y - 1, ".");
        updateTile(x, y, getGameTile(x, y - 1));
        updateTile(x, y - 1, "G");
        anyFall = true;
      } else if (cellAbove === "p") {
        game = gameCopy;
        gameState = gameStateCopy;
        anyFall = false;
        break;
      }
    }
  }
  if (anyFall) {
    pieceLoc[1]++;
  }
  return anyFall;
}

function movePieceLeft() {
  const rows = game.trim().split("\n");
  const columns = rows.map(row => row.split(""));

  const gameCopy = game;
  const gameStateCopy = gameState;

  for (var x = 0; x < 9; x++) {
    for (var y = 0; y < 20; y++) {
      cell = getStateTile(x, y);
      cellRight = getStateTile(x + 1, y);
      if (cell === "." && cellRight === "p") {
        updateTileState(x, y, cellRight);
        updateTileState(x + 1, y, ".");
        updateTile(x, y, getGameTile(x + 1, y));
        updateTile(x + 1, y, "G");
      } else if (cellRight === "p") {
        game = gameCopy;
        gameState = gameStateCopy;
        break;
      }
    }
  }
  if (gameCopy !== game) {
    pieceLoc[0]--;
  }
}

function movePieceRight() {
  const rows = game.trim().split("\n");
  const columns = rows.map(row => row.split(""));

  const gameCopy = game;
  const gameStateCopy = gameState;

  for (var x = 9; x > 0; x--) {
    for (var y = 0; y < 20; y++) {
      cell = getStateTile(x, y);
      cellRight = getStateTile(x - 1, y);
      if (cell === "." && cellRight === "p") {
        updateTileState(x, y, cellRight);
        updateTileState(x - 1, y, ".");
        updateTile(x, y, getGameTile(x - 1, y));
        updateTile(x - 1, y, "G");
      } else if (cellRight === "p") {
        game = gameCopy;
        gameState = gameStateCopy;
        break;
      }
    }
  }
  if (gameCopy !== game) {
    pieceLoc[0]++;
  }
}

function rotatePiece() {
  if (pieceType >= 0 && pieceLoc != [-1, -1]) {
    const gameCopy = game;
    const gameStateCopy = gameState;
    
    var nextPiece = pieces[pieceType][(pieceRot + 1) % 4]
    var nextYOffset = (pieceType===0) ? 2 : 1;
    var pieceRows = nextPiece.trim().split("\n");
    console.log(nextPiece);
    var y = pieceLoc[1]-nextYOffset;
    for (row of pieceRows) {
      var x = pieceLoc[0]-1;
      for (cell of row) {
        if (x>=0 && x<10 && y>=0 && y<20) {
          if (cell === ".") { 
            cell = "G"
            if (getStateTile(x, y) != ".") {
              updateTileState(x, y, ".");
            }
          } 
          else {
            updateTileState(x, y, "p")
          };
          updateTile(x, y, cell);
        }
        x++;
      }
      y++;
    }
    if(gameCopy !== game) {
      pieceRot = (pieceRot+1)%4
    }
  }
}

function update() {
  let anyFall = pieceUpdate();
  if (!anyFall) {
    for (var i = 0; i < 200; i++) {
      if (getStateTile(i % 10, Math.floor(i / 10)) === "p") {
        updateTileState(i % 10, Math.floor(i / 10), "s");
      }
    }
    addPiece(Math.floor(Math.random() * 7));
  }
  setTimeout(update, 1000);
  // Update the game display with the modified map
  setMap(game);
}


onInput("w", () => {
  rotatePiece();
})
onInput("a", () => {
  movePieceLeft();
})
onInput("s", () => {
  pieceUpdate();
})
onInput("d", () => {
  movePieceRight();
})

afterInput(() => {
  setMap(game);
})

update();
// updateTile(7, 2, "P");
// setBackground(White);
